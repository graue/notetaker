Components:

* App - the whole app
  * FolderList - shows "Main", "Archive", "Trash", bolding the
    folder you're currently listing notes in (if any)
  * ContentPane - holds either a NoteList, if listing notes in a
    folder, or a Note if viewing/editing a single note
    * Note - lets you edit a note, or archive/trash it
      * Text box to view and edit note
      * Archive and Trash buttons
    * FilterableNoteList - lists notes in a folder
      * Button to create a new note
      * SearchBox - lets you type search terms to filter notes
      * NoteSummaryList - lists notes in folder which match search
        term
        * NoteSummary - shows a possibly abbreviated view of a note,
          which can be clicked to bring up a full, editable view


Pure CSS side-note: How do they do the thing where I can create, say,
a 3-column layout of equally width columns that stays that way
regardless of the overall width? For example, the pricing layout:

http://purecss.io/layouts/pricing/

has max-width: 980px on the pricing row (with 3 columns). The
resulting width could be anything (in a range from whatever width it
becomes columnar at, to 980). How do they set each column to a third
of that? Wouldn't they have to set width: XXXpx and adjust it with
JavaScript (which is clearly not going on)? I want to see how this
feat is accomplished.


Hmm... should the search text be prop or state? Seemingly it *has* to
be a prop, since a parent component - FilterableNoteList - needs to
know it. But it also seemingly should be state because the component's
event handlers may change it to trigger a UI update. Maybe I need to
do more reading here.


5/16 - I'm (as usual) trying to do too many things at once: convert
the app to Flux architecture with a dispatcher and stores, while also
adding PouchDB support. I think the way this will eventually come
together is I want to make a PouchDB design document for a view sorted
first by folder, then by time - for quick display of folders. But
that's a little too much to think about right now.

The Flux TodoMVC example is a little tricky to adapt to PouchDB
because with Pouch all reads and writes from the store will be
asynchronous (as with the underlying IndexedDB API).

Confession: I don't understand why the Flux example Dispatcher uses
promises. Why must it be async?

This is vexing me... how am I gonna make React work sensibly when all
of my local data (notes) can only be accessed asynchronously? Having
to wait for an async callback to be called complicates each component
(it must either render twice, or be a controller-view that listens on
DB changes and re-renders itself only once the data is in). The
obvious solution is to have one controller-view at the root that gets
all the async data, *then* renders itself and its children, passing
down the needed data to each children. But this makes e.g. the No...
hmm. Maybe just do this actually. Was going to say it makes the note
list and note view less self-contained, but I guess they don't need to
do their own queries.

CouchDB doesn't support partial updates without some extra work,
currently: http://wiki.apache.org/couchdb/Partial_Updates so without
any explicit mention in the docs, I assume PouchDB doesn't, either.
Boo.

Components:

* App - the whole app
  * FolderList - shows "Main", "Archive", "Trash", bolding the
    folder you're currently listing notes in (if any)
  * ContentPane - holds either a NoteList, if listing notes in a
    folder, or a Note if viewing/editing a single note
    * Note - lets you edit a note, or archive/trash it
      * Text box to view and edit note
      * Archive and Trash buttons
    * FilterableNoteList - lists notes in a folder
      * Button to create a new note
      * SearchBox - lets you type search terms to filter notes
      * NoteSummaryList - lists notes in folder which match search
        term
        * NoteSummary - shows a possibly abbreviated view of a note,
          which can be clicked to bring up a full, editable view


Pure CSS side-note: How do they do the thing where I can create, say,
a 3-column layout of equally width columns that stays that way
regardless of the overall width? For example, the pricing layout:

http://purecss.io/layouts/pricing/

has max-width: 980px on the pricing row (with 3 columns). The
resulting width could be anything (in a range from whatever width it
becomes columnar at, to 980). How do they set each column to a third
of that? Wouldn't they have to set width: XXXpx and adjust it with
JavaScript (which is clearly not going on)? I want to see how this
feat is accomplished.


Hmm... should the search text be prop or state? Seemingly it *has* to
be a prop, since a parent component - FilterableNoteList - needs to
know it. But it also seemingly should be state because the component's
event handlers may change it to trigger a UI update. Maybe I need to
do more reading here.


5/16 - I'm (as usual) trying to do too many things at once: convert
the app to Flux architecture with a dispatcher and stores, while also
adding PouchDB support. I think the way this will eventually come
together is I want to make a PouchDB design document for a view sorted
first by folder, then by time - for quick display of folders. But
that's a little too much to think about right now.

The Flux TodoMVC example is a little tricky to adapt to PouchDB
because with Pouch all reads and writes from the store will be
asynchronous (as with the underlying IndexedDB API).

Confession: I don't understand why the Flux example Dispatcher uses
promises. Why must it be async?

This is vexing me... how am I gonna make React work sensibly when all
of my local data (notes) can only be accessed asynchronously? Having
to wait for an async callback to be called complicates each component
(it must either render twice, or be a controller-view that listens on
DB changes and re-renders itself only once the data is in). The
obvious solution is to have one controller-view at the root that gets
all the async data, *then* renders itself and its children, passing
down the needed data to each children. But this makes e.g. the No...
hmm. Maybe just do this actually. Was going to say it makes the note
list and note view less self-contained, but I guess they don't need to
do their own queries.

CouchDB doesn't support partial updates without some extra work,
currently: http://wiki.apache.org/couchdb/Partial_Updates so without
any explicit mention in the docs, I assume PouchDB doesn't, either.
Boo.

5/19: Ah but the FilterableNoteList does need to do its own queries,
for searching and pagination. Say we have 5 tiny example notes. OK,
fine, the controller view at a higher level can pass them on down. But
then say we have 5 MB of notes. We want to lean on PouchDB to search
and paginate them, not duplicate the entire database and do that
ourselves in a view.

OTOH, maybe the FilterableNoteList should itself be a controller-view.


5/20: Holy shit! PouchDB loading and saving of notes *works*!

So what I'm doing is to have FilterableNoteList and Note both be
controller-views. notes and note/rev, respectively, are not props but
state, at first undefined, set when the async load completes.

Annoying side effect: there's a flash of a loading message before the
note appears, even when it's locally stored and should be instant. I
dislike this but dunno what to do. :(

Also, it's not listening for changes, so if you edit the note in a
different tab, it won't be reflected.

I'm afraid that if I *do* start listening for changes, if I don't do
it the right way, there will again be that async loading flash, every
time you change it. But that's silly, right? No need to tear down and
recreate the component, just listen and .setState() asynchronously.


5/21

Just learned: except in "use strict" mode, functions' .bind, .call and
.apply cannot set the this-value to null or undefined. In that case
the global object will be used instead.

Also, es6-promise promises seem to silently swallow exceptions thrown
in my .then() method. Whassup with that. Sure I know it's good
practice to catch them, but if I don't, I expect to see the stacktrace
in the console and stuff. Is this a bug in the es6-promise lib on NPM?
Or crappy expected behavior? This really blows for debugging.

This is expected. Because .then() returns a new Promise and I could
call .catch() on it in the future. Bluebird mentions this problem
extensively in its readme and has a heuristic for warning about
"possibly uncaught" errors. Bleh. Maybe switch to Bluebird then.


Another fun issue with React and async: all async calls to .setState()
must be guarded by an .isMounted() check. If you reload while on a URL
like:

http://localhost:8000/#/note/FA579020-D8D9-7AA2-968C-1E574B1CD8F1

It renders momentarily with a FilterableNoteList visible before the
router does its thing and loads a Note component instead. In the
instant the FNL is visible, it fires an async request, which comes
back when the FNL is no longer mounted. This behavior is pretty
consistent, so at least I caught the bug early, but having to
*manually* guard with .isMounted() all the time seems broken. As I
proceed I'll have to come up with a general solution here.

Components:

* App - the whole app
  * FolderList - shows "Main", "Archive", "Trash", bolding the
    folder you're currently listing notes in (if any)
  * ContentPane - holds either a NoteList, if listing notes in a
    folder, or a Note if viewing/editing a single note
    * Note - lets you edit a note, or archive/trash it
      * Text box to view and edit note
      * Archive and Trash buttons
    * FilterableNoteList - lists notes in a folder
      * Button to create a new note
      * SearchBox - lets you type search terms to filter notes
      * NoteSummaryList - lists notes in folder which match search
        term
        * NoteSummary - shows a possibly abbreviated view of a note,
          which can be clicked to bring up a full, editable view


Pure CSS side-note: How do they do the thing where I can create, say,
a 3-column layout of equally width columns that stays that way
regardless of the overall width? For example, the pricing layout:

http://purecss.io/layouts/pricing/

has max-width: 980px on the pricing row (with 3 columns). The
resulting width could be anything (in a range from whatever width it
becomes columnar at, to 980). How do they set each column to a third
of that? Wouldn't they have to set width: XXXpx and adjust it with
JavaScript (which is clearly not going on)? I want to see how this
feat is accomplished.


Hmm... should the search text be prop or state? Seemingly it *has* to
be a prop, since a parent component - FilterableNoteList - needs to
know it. But it also seemingly should be state because the component's
event handlers may change it to trigger a UI update. Maybe I need to
do more reading here.


5/16 - I'm (as usual) trying to do too many things at once: convert
the app to Flux architecture with a dispatcher and stores, while also
adding PouchDB support. I think the way this will eventually come
together is I want to make a PouchDB design document for a view sorted
first by folder, then by time - for quick display of folders. But
that's a little too much to think about right now.

The Flux TodoMVC example is a little tricky to adapt to PouchDB
because with Pouch all reads and writes from the store will be
asynchronous (as with the underlying IndexedDB API).

Confession: I don't understand why the Flux example Dispatcher uses
promises. Why must it be async?

This is vexing me... how am I gonna make React work sensibly when all
of my local data (notes) can only be accessed asynchronously? Having
to wait for an async callback to be called complicates each component
(it must either render twice, or be a controller-view that listens on
DB changes and re-renders itself only once the data is in). The
obvious solution is to have one controller-view at the root that gets
all the async data, *then* renders itself and its children, passing
down the needed data to each children. But this makes e.g. the No...
hmm. Maybe just do this actually. Was going to say it makes the note
list and note view less self-contained, but I guess they don't need to
do their own queries.

CouchDB doesn't support partial updates without some extra work,
currently: http://wiki.apache.org/couchdb/Partial_Updates so without
any explicit mention in the docs, I assume PouchDB doesn't, either.
Boo.

5/19: Ah but the FilterableNoteList does need to do its own queries,
for searching and pagination. Say we have 5 tiny example notes. OK,
fine, the controller view at a higher level can pass them on down. But
then say we have 5 MB of notes. We want to lean on PouchDB to search
and paginate them, not duplicate the entire database and do that
ourselves in a view.

OTOH, maybe the FilterableNoteList should itself be a controller-view.


5/20: Holy shit! PouchDB loading and saving of notes *works*!

So what I'm doing is to have FilterableNoteList and Note both be
controller-views. notes and note/rev, respectively, are not props but
state, at first undefined, set when the async load completes.

Annoying side effect: there's a flash of a loading message before the
note appears, even when it's locally stored and should be instant. I
dislike this but dunno what to do. :(

Also, it's not listening for changes, so if you edit the note in a
different tab, it won't be reflected.

I'm afraid that if I *do* start listening for changes, if I don't do
it the right way, there will again be that async loading flash, every
time you change it. But that's silly, right? No need to tear down and
recreate the component, just listen and .setState() asynchronously.


5/21

Just learned: except in "use strict" mode, functions' .bind, .call and
.apply cannot set the this-value to null or undefined. In that case
the global object will be used instead.

Also, es6-promise promises seem to silently swallow exceptions thrown
in my .then() method. Whassup with that. Sure I know it's good
practice to catch them, but if I don't, I expect to see the stacktrace
in the console and stuff. Is this a bug in the es6-promise lib on NPM?
Or crappy expected behavior? This really blows for debugging.

This is expected. Because .then() returns a new Promise and I could
call .catch() on it in the future. Bluebird mentions this problem
extensively in its readme and has a heuristic for warning about
"possibly uncaught" errors. Bleh. Maybe switch to Bluebird then.


Another fun issue with React and async: all async calls to .setState()
must be guarded by an .isMounted() check. If you reload while on a URL
like:

http://localhost:8000/#/note/FA579020-D8D9-7AA2-968C-1E574B1CD8F1

It renders momentarily with a FilterableNoteList visible before the
router does its thing and loads a Note component instead. In the
instant the FNL is visible, it fires an async request, which comes
back when the FNL is no longer mounted. This behavior is pretty
consistent, so at least I caught the bug early, but having to
*manually* guard with .isMounted() all the time seems broken. As I
proceed I'll have to come up with a general solution here.


Something I hadn't thought about is, when what's displayed on screen
is being edited in another tab (or in future, on another machine!),
what should happen? I don't have full operational transform or
anything (nor was I planning to), so simultaneous editing isn't
really supported. OTOH, the "changes" we'll be thinking about syncing
are pretty small... anytime you stop typing for 500ms (I may increase
that, but to a few seconds max) it's a new "save". So maybe latest
save wins wouldn't be so bad.

I mean, this is intended to be a single-user app, so this shouldn't
happen much, except when you just leave the page open on one device,
forget about it, and edit on a second device. In that case, latest
save wins is fine.

We also want to update the folder views on an external change. This is
actually a problem now even on one device due to a race condition:

1. Stop typing in a note (debounce timer is set)
2. Quickly go back to the folder view
3. Folder view is rendered without your latest change
4. Debounce timer fires, change is saved

I find the PouchDB doc for db.changes() particularly inadequate. They
mention that changes() returns an event emitter that emits 'change',
'complete', 'create', 'update' and 'delete' events, but say nothing
about the arguments each passes to event handlers. And the 'complete'
event happens "when all the changes have been processed"? What does
that mean, processed by what? And options.live is explained as "Use
longpoll feed". What does it use otherwise? What would it mean for a
change listener to not be live?

I guess the example does tell us what arg is passed, if you read
between the lines. On the db changes emitter,

    .on('change', function(change) { });

is called. So there's one argument. Immediately after that is an
example response:

    {
      "id":"somestuff",
      "seq":21,
      "changes":[{
        "rev":"1-8e6e4c0beac3ec54b27d1df75c7183a8"
      }],
      "doc":{
        "title":"Ch-Ch-Ch-Ch-Changes",
        "_id":"someDocId",
        "_rev":"1-8e6e4c0beac3ec54b27d1df75c7183a8"
      }
    }

So presumably the one argument is an object with that shape, and
perhaps it's the same for 'create', 'update', and 'delete' (each
emitting a subset of what 'change' emits)?

'seq' is a sequence number that can be passed to db.changes(), i.e.,
db.changes({since: 21}), but it's not clear how long-lived the
sequence number is, what determines if you would get a new sequence?
Is it global for all changes to the database? If so, that conflicts
with Couch's philosophy of using UUIDs (rather than counters) for
revisions to make eventual consistency work.


In a totally different area, the "Still loading note list, please
wait" text bugs me. It flashes for one frame always and looks bad.
Should probably ditch that, just leave blank, or something to fill
space. OK, ditched.


5/25: let's make this notes.txt more actionable. After a break, I come
back to this thinking "What should I do next?" and find a lot of "hmm,
I should do this, but no, maybe I should do that. Hmm, I don't like
this feature of PouchDB. Etc." Not very useful.

So, bugs:

* Stop typing in a note, then quickly return to folder list. The
  summary of the note is stale, and never updates. I need some way to
  keep track of pending actions and flush before leaving edit mode
  (which probably means I need to write my own _.debounce analog).
* Note views should listen to db.changes() and update. They currently
  don't, which can be seen by editing in another tab.
* Folder views should also listen to db.changes() and update, visible
  by editing in another tab.

And some UI warts:

* Search box should have a magnifying glass. I attempted this using
  Typicons, but it was ugly, partly because I messed up the padding
  and partly because the typcn-zoom icon is just ugly IMHO. This work
  can be seen in the crappy-icons branch.
* Note view should provide an indication what note the folder is in,
  and a place you can click to return to that folder view.
* Note view for archived notes should have "Unarchive" and "Trash"
  buttons.
* Note view for trashed notes should have a "Restore" (to main)
  button.
* The gray backgrounds should go. They were just to aid me in laying
  things out.
* The grid is meant to be responsive, but isn't. Am I using Pure
  incorrectly? Should look into getting the grid and buttons to
  respond properly to smaller widths.
